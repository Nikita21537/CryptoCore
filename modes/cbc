from src.aes.aes_core import AES128
from src.aes.padding import pad_pkcs7, unpad_pkcs7


class CBC:
    """Реализация режима CBC"""

    def __init__(self, key):
        self.aes = AES128(key)
        self.requires_iv = True

    def encrypt(self, plaintext, iv=None):
        """Шифрование в режиме CBC"""
        if iv is None:
            raise ValueError("IV is required for CBC mode")
        if len(iv) != 16:
            raise ValueError("IV must be 16 bytes")

        # Добавление padding
        plaintext = pad_pkcs7(plaintext)

        # Шифрование
        ciphertext = b''
        prev_block = iv

        for i in range(0, len(plaintext), 16):
            block = plaintext[i:i + 16]

            # XOR с предыдущим блоком шифротекста (или IV)
            xored_block = bytes(a ^ b for a, b in zip(block, prev_block))

            # Шифрование
            encrypted_block = self.aes.encrypt_block(xored_block)
            ciphertext += encrypted_block
            prev_block = encrypted_block

        return ciphertext

    def decrypt(self, ciphertext, iv=None):
        """Дешифрование в режиме CBC"""
        if iv is None:
            raise ValueError("IV is required for CBC mode")
        if len(iv) != 16:
            raise ValueError("IV must be 16 bytes")
        if len(ciphertext) % 16 != 0:
            raise ValueError("Ciphertext length must be multiple of 16 bytes")

        # Дешифрование
        plaintext = b''
        prev_block = iv

        for i in range(0, len(ciphertext), 16):
            block = ciphertext[i:i + 16]

            # Дешифрование
            decrypted_block = self.aes.decrypt_block(block)

            # XOR с предыдущим блоком шифротекста (или IV)
            plaintext_block = bytes(a ^ b for a, b in zip(decrypted_block, prev_block))
            plaintext += plaintext_block

            prev_block = block

        # Удаление padding
        return unpad_pkcs7(plaintext)
